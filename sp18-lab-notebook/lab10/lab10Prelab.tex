
\section{Odds and Ends}

This prelab cover some important topics that extend and simplify how we work with loops and methods that we didn't have time for in previous labs. 

\subsection{For-Each Loops}

While loops used to iterate over an array often looked very similar, so for loops were introduced as a more concise way to handle the task. \textbf{For-Each Loops} were introduced in Java 5 as an even more concise way to deal with these tasks, and are preferred whenever the programmer intends to iterate over each element of an array \textbf{sequentially} (that is, starting with the first, then the second, and so on until the last element). 

A for-each loop eliminates the index variable (i) entirely. Instead, the programmer must define a new variable that will hold a single element of the array through each iteration of the loop. The same keyword (for) is used. Following the definition of this new variable, the programmer must include a colon (:) and then an expression yielding the array to be iterated over (usually just a variable reference).

\begin{exa}
Consider the following array of Strings:

\begin{code}
String[] names = new String[] { "Jane", "Billy", "Susie" };
\end{code}

A for loop could be used to print each name out:

\begin{code}
for(int i=0; i < names.length; i++) {
  System.out.println(names[i]);
}
\end{code}

The following for-each loop will perform the exact same task with a little less code, and is a little easier to read and understand:

\begin{code}
for(String name : names) {
  System.out.println(name);
}
\end{code}
\end{exa}



\subsection{Variable Number of Arguments}

All the method definitions we've examined thus far have required the programmer to be explicit about the \textbf{number of parameters} for the method and their types. Thus the programmer can't define a method that could take either 1, 2, or 3 arguments -- the number of arguments would always need to be the same. 

There is a way around this limitation. We could define a method that has an array-type parameter. The array argument we pass in to this method could be of any length, so we could package our arguments inside of it.

\begin{exa}
If we wanted to write a method that would add several numbers together, we could package all those numbers in an array before we pass them to the method:

\begin{code}
int sum(int[] numbers) {
  int total = 0;
  for(int number : numbers) {
    total += number;
  }
  return total;
}
\end{code}

If we had three integer variables we wanted to add together, we could then pass them in within a literal array:

\begin{code}
sum(new int[] {a, b, c})
\end{code}

\end{exa}

Since Java 5, variable number of arguments has been supported in Java, allowing us to perform the same task as the method above, but with a cleaner looking syntax. Instead of declaring that the method accepts an array, an ellipsis is included in between the type of the arguments being passed in and a variable name for an array that will hold all of the values. 

\begin{exa}
We could rewrite the example above using variable arguments as follows:

\begin{code}
int sum(int ... numbers) {
  int total = 0;
  for(int number : numbers) {
    total += number;
  }
  return total;
}
\end{code}

There is very little difference in the method definition, but now we don't need to create a literal array when we pass in a variable number of arguments. This version of sum can be called as follows:

\begin{code}
sum(a, b, c)
\end{code}
\end{exa}


\subsection{Overloading Static Methods}
What if the programmer wanted to develop a method that could take more than one type of argument? You may have noticed in the past that \textbf{Math.abs} works with either \textbf{int} values or \textbf{double} values. That is because there are two different implementations of \textbf{Math.abs}, one for each of these parameter data types. This is called \textbf{overloading}.

Methods in Java are not identified by their name alone. If you were to call Math.abs(5), the Java compiler will search for a method named \textit{abs} that has exactly one parameter of type \textit{int}. There may be another method named \textit{abs} that has a parameter of type \textit{double}, or more than one parameter, or no parameters, etc..

\begin{exa}

Consider the following method definitions:

\begin{code}
int abs(int a) {
  System.out.println("abs was called with an int");
  return a > 0 ? a : -a;
}

double abs(double a) {
  System.out.println("abs was called with an double");
  return a > 0 ? a : -a;
}
\end{code}

The implementations of these methods look nearly identical, but if you enter them in to jshell and then evaluate the following statements:

\begin{code}
abs(-5);
abs(-5.0);
\end{code}

You will see that one returns an integer value and the other returns a double value, as well as each printing out a different message. 
\end{exa}

\section{Before Next Class}

Please answer the following questions before you arrive to class:

\begin{exer}

\begin{itemize}

\item What keyword is used with a for-each loop?

  \evalline
  
\item What new syntax is used when defining a method with a variable number of arguments? 

  \evalline
  
\end{itemize}

\end{exer}

Bring your completed pre-lab sheet with you to class for Week \#7. Also submit your answers online on the Moodle prelab assignment.  

